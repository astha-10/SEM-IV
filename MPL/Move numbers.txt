DATA_SEG SEGMENT
        SRC_ARY DB 26H, 11H, 22H, 33H, 44H
        DST_ARY DB 5 DUP(0)
DATA_SEG ENDS

CODE_SEG SEGMENT
	ASSUME CS:CODE_SEG, DS:DATA_SEG

START: 	MOV AX,DATA_SEG  	;initialise data segment reg
	MOV DS,AX
	
	LEA SI, SRC_ARY
	LEA DI, DST_ARY
	MOV CX, 5 		;load the counter

NEXT:  MOV AL, [SI]     	;read the source array element
       MOV [DI], AL
       INC SI 			;increment source pointer
       INC DI 			;increment destination pointer
       LOOP NEXT

       MOV AH,4CH       	;exit to DOS
       INT 21H
CODE_SEG ENDS
END START









Sure, let's go through each line of this assembly code:

1. `DATA_SEG SEGMENT`: Declares the start of a segment named `DATA_SEG` where data variables will be stored.

2. `SRC_ARY DB 26H, 11H, 22H, 33H, 44H`: Declares a byte array named `SRC_ARY` and initializes it with the values `26H`, `11H`, `22H`, `33H`, and `44H`.

3. `DST_ARY DB 5 DUP(0)`: Declares another byte array named `DST_ARY` with a size of 5 elements, each initialized to `0`.

4. `DATA_SEG ENDS`: Declares the end of the `DATA_SEG` segment.

5. `CODE_SEG SEGMENT`: Declares the start of a segment named `CODE_SEG` where the actual code will be stored.

6. `ASSUME CS:CODE_SEG, DS:DATA_SEG`: Tells the assembler to assume that the code segment (`CS`) is `CODE_SEG` and the data segment (`DS`) is `DATA_SEG`.

7. `START: MOV AX,DATA_SEG`: Moves the starting address of the `DATA_SEG` segment to the `AX` register.

8. `MOV DS,AX`: Moves the contents of the `AX` register (which now holds the starting address of `DATA_SEG`) to the `DS` register, effectively initializing the `DS` register to point to the `DATA_SEG` segment.

9. `LEA SI, SRC_ARY`: Loads the effective address of `SRC_ARY` into the `SI` register, pointing to the start of the source array.

10. `LEA DI, DST_ARY`: Loads the effective address of `DST_ARY` into the `DI` register, pointing to the start of the destination array.

11. `MOV CX, 5`: Initializes the `CX` register to `5`, representing the number of elements to copy.

12. `NEXT: MOV AL, [SI]`: Moves the byte at the memory location pointed to by `SI` (source array) into the `AL` register.

13. `MOV [DI], AL`: Moves the byte in `AL` to the memory location pointed to by `DI` (destination array), effectively copying the byte from source to destination.

14. `INC SI`: Increments the `SI` register to point to the next element in the source array.

15. `INC DI`: Increments the `DI` register to point to the next element in the destination array.

16. `LOOP NEXT`: Decrements the `CX` register and jumps to the `NEXT` label if `CX` is not zero, effectively looping to copy the next element.

17. `MOV AH,4CH`: Sets up the DOS exit function.

18. `INT 21H`: Generates an interrupt to call the DOS function, effectively ending the program.

19. `CODE_SEG ENDS`: Declares the end of the `CODE_SEG` segment.

20. `END START`: Marks the end of the program, specifying that the program execution should start at the `START` label.
