DATA_SEG SEGMENT
	 NUM1 DB 12H
	 NUM2 DW 5678H
	 NUM3 DB 0
	 NUM4 DW 0
	 ARY1 DB 00H,11H,22H,33H,44H,55H,66H,77H,88H,99H
 	 ARY2 DB 30H,31H,32H,33H,34H,35H,36H,37H,38,39H
 	 ARY3 DB 10 DUP(0)
DATA_SEG ENDS

CODE_SEG SEGMENT
	 ASSUME CS:CODE_SEG, DS:DATA_SEG

START: MOV AX,DATA_SEG ;initialise data segment reg
 	 MOV DS,AX 	
		;immediate addressing mode
 	MOV AL,24H
	MOV CX,1357H 	
		;register addressing mode
 	MOV AH,AL
 	MOV DX,CX	
		;direct addressing mode
 	MOV AL,NUM1
	MOV BX,NUM2
 	MOV NUM3,AL	
		;load offset of ARY1, ARY2 & ARY3
 	MOV BX,OFFSET ARY1
 	MOV SI,OFFSET ARY2
 	MOV DI,OFFSET ARY3
		;indirect addressing mode
	MOV CL,[BX]
 	MOV CH,[SI]
 	MOV [DI],CH
 		;based addressing mode
	MOV DL,3[BX]
 		;indexed addressing mode
 	MOV 7[DI],DL
 	MOV AH,4CH 	
		;exit to DOS
 	INT 21H
CODE_SEG ENDS

END START









Here's an explanation of each line in the assembly code you provided:

1. `DATA_SEG SEGMENT`: Declares the start of a segment named `DATA_SEG` where data variables will be stored.

2. `NUM1 DB 12H`: Declares a byte-sized variable named `NUM1` and initializes it with the value `12H` (18 in decimal).

3. `NUM2 DW 5678H`: Declares a word-sized variable named `NUM2` and initializes it with the value `5678H` (22136 in decimal).

4. `NUM3 DB 0`: Declares a byte-sized variable named `NUM3` and initializes it with the value `0`.

5. `NUM4 DW 0`: Declares a word-sized variable named `NUM4` and initializes it with the value `0`.

6. `ARY1 DB 00H,11H,22H,33H,44H,55H,66H,77H,88H,99H`: Declares a byte array named `ARY1` and initializes it with the values `00H`, `11H`, `22H`, ..., `99H`.

7. `ARY2 DB 30H,31H,32H,33H,34H,35H,36H,37H,38,39H`: Declares another byte array named `ARY2` and initializes it with the values `30H`, `31H`, `32H`, ..., `39H`.

8. `ARY3 DB 10 DUP(0)`: Declares another byte array named `ARY3` with a size of 10 elements, each initialized to `0`.

9. `DATA_SEG ENDS`: Declares the end of the `DATA_SEG` segment.

10. `CODE_SEG SEGMENT`: Declares the start of a segment named `CODE_SEG` where the actual code will be stored.

11. `ASSUME CS:CODE_SEG, DS:DATA_SEG`: Tells the assembler to assume that the code segment (`CS`) is `CODE_SEG` and the data segment (`DS`) is `DATA_SEG`.

12. `START: MOV AX, DATA_SEG`: Moves the starting address of the `DATA_SEG` segment to the `AX` register.

13. `MOV DS, AX`: Moves the contents of the `AX` register (which now holds the starting address of `DATA_SEG`) to the `DS` register, effectively initializing the `DS` register to point to the `DATA_SEG` segment.

14. `MOV AL, 24H`: Moves the immediate value `24H` into the `AL` register.

15. `MOV CX, 1357H`: Moves the immediate value `1357H` into the `CX` register.

16. `MOV AH, AL`: Moves the contents of the `AL` register into the `AH` register.

17. `MOV DX, CX`: Moves the contents of the `CX` register into the `DX` register.

18. `MOV AL, NUM1`: Moves the value of `NUM1` (which is `12H` or 18 in decimal) into the `AL` register.

19. `MOV BX, NUM2`: Moves the value of `NUM2` (which is `5678H` or 22136 in decimal) into the `BX` register.

20. `MOV NUM3, AL`: Moves the value in `AL` into the memory location of `NUM3`.

21. `MOV BX, OFFSET ARY1`: Loads the offset of `ARY1` into the `BX` register.

22. `MOV SI, OFFSET ARY2`: Loads the offset of `ARY2` into the `SI` register.

23. `MOV DI, OFFSET ARY3`: Loads the offset of `ARY3` into the `DI` register.

24. `MOV CL, [BX]`: Moves the byte at the memory location pointed to by `BX` into the `CL` register.

25. `MOV CH, [SI]`: Moves the byte at the memory location pointed to by `SI` into the `CH` register.

26. `MOV [DI], CH`: Moves the contents of the `CH` register into the memory location pointed to by `DI`.

27. `MOV DL, 3[BX]`: Moves the byte at the memory location 3 bytes after the location pointed to by `BX` into the `DL` register.

28. `MOV 7[DI], DL`: Moves the contents of the `DL` register into the memory location 7 bytes after the location pointed to by `DI`.

29. `MOV AH, 4CH`: Sets up the DOS exit function.

30. `INT 21H`: Generates an interrupt to call the DOS function, effectively ending the program.

31. `CODE_SEG ENDS`: Declares the end of the `CODE_SEG` segment.

32. `END START`: Marks the end of the program, specifying that the program execution should start at the `START` label.